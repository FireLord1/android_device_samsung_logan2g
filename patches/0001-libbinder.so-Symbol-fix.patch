From fa4f46019b27608848bd685451391439e6698a51 Mon Sep 17 00:00:00 2001
From: Aman Kumar <amankumarmicro@gmail.com>
Date: Thu, 25 Feb 2016 03:56:53 +0530
Subject: [PATCH] libbinder.so | Symbol fix

---
 native/include/binder/IMemory.h                  |   7 +-
 native/include/binder/MemoryHeapIon.h            |  77 +--
 native/include/binder/MemoryHeapPmem.h           |  79 ---
 native/libs/binder/Android.mk                    |  50 +-
 native/libs/binder/IMemory.cpp                   |  29 +-
 native/libs/binder/IPCThreadState.cpp            |  60 ++-
 native/libs/binder/IServiceManager.cpp           |  15 +-
 native/libs/binder/MemoryBase.cpp                |   9 -
 native/libs/binder/MemoryHeapIon.cpp             | 594 +++++++++++++++++------
 native/libs/binder/MemoryHeapPmem.cpp            | 248 ----------
 native/libs/binder/Parcel.cpp                    |   6 +-
 native/libs/binder/ion.h                         | 344 +++++++++++++
 native/libs/binder/ion_sprd.h                    |  66 +++
 native/services/surfaceflinger/Android.mk        |   5 +
 native/services/surfaceflinger/DisplayDevice.cpp |  10 +-
 15 files changed, 994 insertions(+), 605 deletions(-)
 delete mode 100644 native/include/binder/MemoryHeapPmem.h
 delete mode 100644 native/libs/binder/MemoryHeapPmem.cpp
 mode change 100644 => 100755 native/libs/binder/Parcel.cpp
 create mode 100644 native/libs/binder/ion.h
 create mode 100644 native/libs/binder/ion_sprd.h
 mode change 100755 => 100644 native/services/surfaceflinger/DisplayDevice.cpp

diff --git a/native/include/binder/IMemory.h b/native/include/binder/IMemory.h
index 178ef85..2d0db00 100644
--- a/native/include/binder/IMemory.h
+++ b/native/include/binder/IMemory.h
@@ -36,12 +36,7 @@ public:
 
     // flags returned by getFlags()
     enum {
-        READ_ONLY   = 0x00000001,
-#ifdef USE_MEMORY_HEAP_ION
-        USE_ION_FD  = 0x00008000
-#else
-        USE_ION_FD  = 0x00000008
-#endif
+        READ_ONLY   = 0x00000001
     };
 
     virtual int         getHeapID() const = 0;
diff --git a/native/include/binder/MemoryHeapIon.h b/native/include/binder/MemoryHeapIon.h
index 7e059f4..3e155f4 100644
--- a/native/include/binder/MemoryHeapIon.h
+++ b/native/include/binder/MemoryHeapIon.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2008 The Android Open Source Project
- * Copyright 2011, Samsung Electronics Co. LTD
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,55 +14,58 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/*!
- * \file MemoryHeapIon.h
- * \brief header file for MemoryHeapIon
- * \author MinGu, Jeon(mingu85.jeon)
- * \date 2011/11/20
- *
- * <b>Revision History: </b>
- * - 2011/11/21 : MinGu, Jeon(mingu85.jeon)) \n
- * Initial version
- * - 2012/11/29 : MinGu, Jeon(mingu85.jeon)) \n
- * Change name
- */
 
 #ifndef ANDROID_MEMORY_HEAP_ION_H
 #define ANDROID_MEMORY_HEAP_ION_H
 
-#include <binder/IMemory.h>
-#include <binder/MemoryHeapBase.h>
 #include <stdlib.h>
+#include <stdint.h>
 
-#define MHB_ION_HEAP_SYSTEM_CONTIG_MASK     (1 << 1)
-#define MHB_ION_HEAP_EXYNOS_CONTIG_MASK     (1 << 4)
-#define MHB_ION_HEAP_EXYNOS_MASK            (1 << 5)
-#define MHB_ION_HEAP_SYSTEM_MASK            (1 << 6)
-
-#define MHB_ION_FLAG_CACHED                 (1 << 16)
-#define MHB_ION_FLAG_CACHED_NEEDS_SYNC      (1 << 17)
-#define MHB_ION_FLAG_PRESERVE_KMAP          (1 << 18)
+#include <binder/MemoryHeapBase.h>
+#include <binder/IMemory.h>
+#include <utils/SortedVector.h>
+#include <utils/threads.h>
 
-#define MHB_ION_EXYNOS_VIDEO_MASK           (1 << 21)
-#define MHB_ION_EXYNOS_MFC_INPUT_MASK       (1 << 25)
-#define MHB_ION_EXYNOS_MFC_OUTPUT_MASK      (1 << 26)
-#define MHB_ION_EXYNOS_GSC_MASK             (1 << 27)
-#define MHB_ION_EXYNOS_FIMD_VIDEO_MASK      (1 << 28)
+struct ion_handle;
 
 namespace android {
 
+class MemoryHeapBase;
+
+// ---------------------------------------------------------------------------
+
 class MemoryHeapIon : public MemoryHeapBase
 {
 public:
-    enum {
-        USE_ION_FD = IMemoryHeap::USE_ION_FD
-    };
-    MemoryHeapIon(size_t size, uint32_t flags = 0, char const* name = NULL);
-    MemoryHeapIon(int fd, size_t size, uint32_t flags = 0, uint32_t offset = 0);
+    MemoryHeapIon(const char*, size_t, uint32_t, long unsigned int);
+    MemoryHeapIon();
     ~MemoryHeapIon();
+
+    status_t mapIonFd(int fd, size_t size, unsigned long memory_type, int flags);
+
+    status_t ionInit(int ionFd, void *base, int size, int flags,
+                                const char* device, struct ion_handle *handle,
+                                int ionMapFd);
+    int get_phy_addr_from_ion(int *phy_addr, int *size);
+    int flush_ion_buffer(void *v_addr, void *p_addr,int size);
+    int get_gsp_iova(int *mmu_addr, int *size);
+    int free_gsp_iova(int mmu_addr, int size);
+    int get_mm_iova(int *mmu_addr, int *size);
+    int free_mm_iova(int mmu_addr, int size);
+    static int Get_gsp_iova(int buffer_fd, int *mmu_addr, int *size);
+    static int Free_gsp_iova(int buffer_fd, int mmu_addr, int size);
+    static int Get_mm_iova(int buffer_fd,int *mmu_addr, int *size);
+    static int Free_mm_iova(int buffer_fd,int mmu_addr, int size);
+    static int Get_phy_addr_from_ion(int fd, int *phy_addr, int *size);/*fd is "fd of the corresponding ion hanlde"*/
+    static int Flush_ion_buffer(int buffer_fd, void *v_addr,void *p_addr, int size);
+    static bool Gsp_iommu_is_enabled(void);
+    static bool Mm_iommu_is_enabled(void);
+
 private:
-    int mIonClient;
-};
+    int mIonDeviceFd;  /*fd we get from open("/dev/ion")*/
+    struct ion_handle *mIonHandle;  /*handle we get from ION_IOC_ALLOC*/ };
+
+// ---------------------------------------------------------------------------
+}; // namespace android
 
-};
-#endif
+#endif // ANDROID_MEMORY_HEAP_ION_H
diff --git a/native/include/binder/MemoryHeapPmem.h b/native/include/binder/MemoryHeapPmem.h
deleted file mode 100644
index e1660c4..0000000
--- a/native/include/binder/MemoryHeapPmem.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_MEMORY_HEAP_PMEM_H
-#define ANDROID_MEMORY_HEAP_PMEM_H
-
-#include <stdlib.h>
-#include <stdint.h>
-
-#include <binder/MemoryHeapBase.h>
-#include <binder/IMemory.h>
-#include <utils/SortedVector.h>
-#include <utils/threads.h>
-
-namespace android {
-
-class MemoryHeapBase;
-
-// ---------------------------------------------------------------------------
-
-class MemoryHeapPmem : public MemoryHeapBase
-{
-public:
-    class MemoryPmem : public BnMemory {
-    public:
-        MemoryPmem(const sp<MemoryHeapPmem>& heap);
-        ~MemoryPmem();
-    protected:
-        const sp<MemoryHeapPmem>&  getHeap() const { return mClientHeap; }
-    private:
-        friend class MemoryHeapPmem;
-        virtual void revoke() = 0;
-        sp<MemoryHeapPmem>  mClientHeap;
-    };
-    
-    MemoryHeapPmem(const sp<MemoryHeapBase>& pmemHeap, uint32_t flags = 0);
-    ~MemoryHeapPmem();
-
-    /* HeapInterface additions */
-    virtual sp<IMemory> mapMemory(size_t offset, size_t size);
-
-    /* make the whole heap visible (you know who you are) */
-    virtual status_t slap();
-    
-    /* hide (revoke) the whole heap (the client will see the garbage page) */
-    virtual status_t unslap();
-    
-    /* revoke all allocations made by this heap */
-    virtual void revoke();
-
-private:
-    /* use this to create your own IMemory for mapMemory */
-    virtual sp<MemoryPmem> createMemory(size_t offset, size_t size);
-    void remove(const wp<MemoryPmem>& memory);
-
-private:
-    sp<MemoryHeapBase>              mParentHeap;
-    mutable Mutex                   mLock;
-    SortedVector< wp<MemoryPmem> >  mAllocations;
-};
-
-
-// ---------------------------------------------------------------------------
-}; // namespace android
-
-#endif // ANDROID_MEMORY_HEAP_PMEM_H
diff --git a/native/libs/binder/Android.mk b/native/libs/binder/Android.mk
index 7861fef..560f556 100644
--- a/native/libs/binder/Android.mk
+++ b/native/libs/binder/Android.mk
@@ -29,60 +29,40 @@ sources := \
     MemoryDealer.cpp \
     MemoryBase.cpp \
     MemoryHeapBase.cpp \
+    MemoryHeapIon.cpp \
     Parcel.cpp \
     PermissionCache.cpp \
     ProcessState.cpp \
     Static.cpp \
     TextOutput.cpp \
 
-ifeq ($(BOARD_NEEDS_MEMORYHEAPPMEM),true)
-sources += \
-    MemoryHeapPmem.cpp
-endif
-
-ifeq ($(BOARD_NEEDS_MEMORYHEAPION),true)
-sources += \
-    MemoryHeapIon.cpp
-endif
-
 LOCAL_PATH:= $(call my-dir)
 
-include $(CLEAR_VARS)
+$(warning sec:${USE_PROJECT_SEC})
 
-ifeq ($(BOARD_NEEDS_MEMORYHEAPION),true)
-LOCAL_SHARED_LIBRARIES += libion_exynos
-LOCAL_CFLAGS += -DUSE_MEMORY_HEAP_ION
-ifneq ($(TARGET_SLSI_VARIANT),)
-PLATFORM_DIR := $(TARGET_BOARD_PLATFORM)-$(TARGET_SLSI_VARIANT)
-else
-PLATFORM_DIR := $(TARGET_BOARD_PLATFORM)
-endif
-LOCAL_C_INCLUDES += hardware/samsung_slsi/$(PLATFORM_DIR)/include
+include $(CLEAR_VARS)
+ifeq ($(USE_PROJECT_SEC),true)
+LOCAL_C_INCLUDES := $(LOCAL_PATH) \
+$(TOP)/external/sqlite/dist
+LOCAL_SHARED_LIBRARIES := libsqlite
+LOCAL_CFLAGS += -DUSE_PROJECT_SEC
+LOCAL_LDFLAGS += $(TOP)/frameworks/native/libs/libsecbinder/libsecbinder.a
 endif
-
 LOCAL_LDLIBS += -lpthread
 LOCAL_MODULE := libbinder
 LOCAL_SHARED_LIBRARIES += liblog libcutils libutils
+LOCAL_C_INCLUDES += \
+    $(TARGET_OUT_INTERMEDIATES)/KERNEL/usr/include/video/ \
+    $(TARGET_OUT_INTERMEDIATES)/KERNEL/
 LOCAL_SRC_FILES := $(sources)
-
 include $(BUILD_SHARED_LIBRARY)
 
 include $(CLEAR_VARS)
-
-ifeq ($(BOARD_NEEDS_MEMORYHEAPION),true)
-LOCAL_SHARED_LIBRARIES += libion_exynos
-LOCAL_CFLAGS += -DUSE_MEMORY_HEAP_ION
-ifneq ($(TARGET_SLSI_VARIANT),)
-PLATFORM_DIR := $(TARGET_BOARD_PLATFORM)-$(TARGET_SLSI_VARIANT)
-else
-PLATFORM_DIR := $(TARGET_BOARD_PLATFORM)
-endif
-LOCAL_C_INCLUDES += hardware/samsung_slsi/$(PLATFORM_DIR)/include
-endif
-
 LOCAL_LDLIBS += -lpthread
 LOCAL_MODULE := libbinder
 LOCAL_STATIC_LIBRARIES += libutils
 LOCAL_SRC_FILES := $(sources)
-
+LOCAL_C_INCLUDES += \
+    $(TARGET_OUT_INTERMEDIATES)/KERNEL/usr/include/video/ \
+    $(TARGET_OUT_INTERMEDIATES)/KERNEL/
 include $(BUILD_STATIC_LIBRARY)
diff --git a/native/libs/binder/IMemory.cpp b/native/libs/binder/IMemory.cpp
index c5d9d98..07cb41a 100644
--- a/native/libs/binder/IMemory.cpp
+++ b/native/libs/binder/IMemory.cpp
@@ -32,10 +32,6 @@
 #include <binder/Parcel.h>
 #include <utils/CallStack.h>
 
-#ifdef USE_MEMORY_HEAP_ION
-#include "ion.h"
-#endif
-
 #define VERBOSE   0
 
 namespace android {
@@ -303,14 +299,6 @@ void BpMemoryHeap::assertReallyMapped() const
         ALOGE_IF(err, "binder=%p transaction failed fd=%d, size=%ld, err=%d (%s)",
                 asBinder().get(), parcel_fd, size, err, strerror(-err));
 
-#ifdef USE_MEMORY_HEAP_ION
-        ion_client ion_client_num = -1;
-        if (flags & USE_ION_FD) {
-            ion_client_num = ion_client_create();
-            ALOGE_IF(ion_client_num < 0, "BpMemoryHeap : ion client creation error");
-        }
-#endif
-
         int fd = dup( parcel_fd );
         ALOGE_IF(fd==-1, "cannot dup fd=%d, size=%ld, err=%d (%s)",
                 parcel_fd, size, err, strerror(errno));
@@ -323,16 +311,7 @@ void BpMemoryHeap::assertReallyMapped() const
         Mutex::Autolock _l(mLock);
         if (mHeapId == -1) {
             mRealHeap = true;
-
-#ifdef USE_MEMORY_HEAP_ION
-        if (flags & USE_ION_FD) {
-            if (ion_client_num < 0)
-                mBase = MAP_FAILED;
-            else
-                mBase = ion_map(fd, size, offset);
-            } else
-#endif
-                mBase = mmap(0, size, access, MAP_SHARED, fd, offset);
+            mBase = mmap(0, size, access, MAP_SHARED, fd, offset);
             if (mBase == MAP_FAILED) {
                 ALOGE("cannot map BpMemoryHeap (binder=%p), size=%ld, fd=%d (%s)",
                         asBinder().get(), size, fd, strerror(errno));
@@ -344,12 +323,6 @@ void BpMemoryHeap::assertReallyMapped() const
                 android_atomic_write(fd, &mHeapId);
             }
         }
-#ifdef USE_MEMORY_HEAP_ION
-        if (ion_client_num < 0)
-            ion_client_num = -1;
-        else
-            ion_client_destroy(ion_client_num);
-#endif
     }
 }
 
diff --git a/native/libs/binder/IPCThreadState.cpp b/native/libs/binder/IPCThreadState.cpp
index aaad104..b0c8f51 100644
--- a/native/libs/binder/IPCThreadState.cpp
+++ b/native/libs/binder/IPCThreadState.cpp
@@ -75,6 +75,11 @@ static const char* getCommandString(size_t idx);
 static const void* printReturnCommand(TextOutput& out, const void* _cmd);
 static const void* printCommand(TextOutput& out, const void* _cmd);
 
+void initKeyService(const String16& name, const sp<IBinder>& svc);
+bool doJudge(int uid, const sp<IBinder>& svc, unsigned int oprID, Parcel& data,  Parcel &reply);
+
+
+
 // This will result in a missing symbol failure if the IF_LOG_COMMANDS()
 // conditionals don't get stripped...  but that is probably what we want.
 #if !LOG_NDEBUG
@@ -362,10 +367,6 @@ status_t IPCThreadState::clearLastError()
     return err;
 }
 
-extern "C" int _ZN7android14IPCThreadState13getCallingPidEv(IPCThreadState *state) {
-    return state->getCallingPid();
-}
-
 int IPCThreadState::getCallingPid() const
 {
     return mCallingPid;
@@ -561,7 +562,23 @@ status_t IPCThreadState::transact(int32_t handle,
             << handle << " / code " << TypeCode(code) << ": "
             << indent << data << dedent << endl;
     }
-    
+#ifdef USE_PROJECT_SEC
+    if (handle == 0) {
+        if (code == IServiceManager::ADD_SERVICE_TRANSACTION) {
+		data.setDataPosition(0);
+            int32_t policy = data.readInt32();
+            String16 service = data.readString16();
+            //MYLOG_ONEWAY("fhy interface: %s", String8(service).string());
+            String16 name = data.readString16();
+            //MYLOG_ONEWAY("fhy name: %s", String8(name).string());
+            sp<IBinder> b = data.readStrongBinder();
+            //MYLOG_ONEWAY("fhy b: 0x%x", b.get());
+            data.setDataPosition(0);
+            initKeyService(name , b);
+        }
+    }
+#endif
+
     if (err == NO_ERROR) {
         LOG_ONEWAY(">>>> SEND from pid %d uid %d %s", getpid(), getuid(),
             (flags & TF_ONE_WAY) == 0 ? "READ REPLY" : "ONE WAY");
@@ -944,7 +961,8 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
     BBinder* obj;
     RefBase::weakref_type* refs;
     status_t result = NO_ERROR;
-    
+
+
     switch (cmd) {
     case BR_ERROR:
         result = mIn.readInt32();
@@ -1026,10 +1044,6 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
                 "Not enough command data for brTRANSACTION");
             if (result != NO_ERROR) break;
             
-            const pid_t origPid = mCallingPid;
-            const uid_t origUid = mCallingUid;
-            Parcel reply;
-            {
             Parcel buffer;
             buffer.ipcSetDataReference(
                 reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer),
@@ -1037,6 +1051,9 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
                 reinterpret_cast<const size_t*>(tr.data.ptr.offsets),
                 tr.offsets_size/sizeof(size_t), freeBuffer, this);
             
+            const pid_t origPid = mCallingPid;
+            const uid_t origUid = mCallingUid;
+            
             mCallingPid = tr.sender_pid;
             mCallingUid = tr.sender_euid;
             
@@ -1060,8 +1077,9 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
                 }
             }
 
-            //ALOGI(">>>> TRANSACT from pid %d uid %d\n", mCallingPid, mCallingUid);
+//            ALOGI(">>>> TRANSACT from pid %d uid %d\n", mCallingPid, mCallingUid);
             
+            Parcel reply;
             IF_LOG_TRANSACTIONS() {
                 TextOutput::Bundle _b(alog);
                 alog << "BR_TRANSACTION thr " << (void*)pthread_self()
@@ -1075,14 +1093,24 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
             }
             if (tr.target.ptr) {
                 sp<BBinder> b((BBinder*)tr.cookie);
+#ifdef USE_PROJECT_SEC
+//                ALOGI("SPRD Security begin to judge");
+                bool bFind = doJudge(mCallingUid, b, tr.code, buffer,reply);
+                if(!bFind)
+                {
+                    ALOGI("YZL Add after doJudge PERMISSION_DENIED");
+                }
+                else
+#endif
+                {
                 const status_t error = b->transact(tr.code, buffer, &reply, tr.flags);
                 if (error < NO_ERROR) reply.setError(error);
+                }
 
             } else {
                 const status_t error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
                 if (error < NO_ERROR) reply.setError(error);
             }
-            }
             
             //ALOGI("<<<< TRANSACT from pid %d restore pid %d uid %d\n",
             //     mCallingPid, origPid, origUid);
@@ -1130,9 +1158,15 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
     case BR_SPAWN_LOOPER:
         mProcess->spawnPooledThread(false);
         break;
-        
+
+    //For Bug#305183, to deal with BR_TRANSACTION_COMPLETE cmd
+    case BR_TRANSACTION_COMPLETE:
+        ALOGE("*** BAD COMMAND: BR_TRANSACTION_COMPLETE(%x) for executeCommand from Binder driver\n", cmd);
+        break;
+
     default:
         printf("*** BAD COMMAND %d received from Binder driver\n", cmd);
+        ALOGE("*** BAD COMMAND %x received from Binder driver\n", cmd);
         result = UNKNOWN_ERROR;
         break;
     }
diff --git a/native/libs/binder/IServiceManager.cpp b/native/libs/binder/IServiceManager.cpp
index a341ca8..00c512c 100644
--- a/native/libs/binder/IServiceManager.cpp
+++ b/native/libs/binder/IServiceManager.cpp
@@ -138,8 +138,19 @@ public:
         for (n = 0; n < 5; n++){
             sp<IBinder> svc = checkService(name);
             if (svc != NULL) return svc;
-            ALOGI("Waiting for service %s...\n", String8(name).string());
-            sleep(1);
+	    #ifndef USE_PROJECT_SEC
+		ALOGI("Waiting for service %s...\n", String8(name).string());
+		sleep(1);
+	    #else
+		if (strcmp("security",String8(name).string())) {
+			ALOGI("Waiting for service %s...\n", String8(name).string());
+			sleep(1);
+		}else{
+			ALOGI("Waiting for service %s no sleep...\n", String8(name).string());
+			break;
+		}
+	    #endif
+
         }
         return NULL;
     }
diff --git a/native/libs/binder/MemoryBase.cpp b/native/libs/binder/MemoryBase.cpp
index 5c82330..033066b 100644
--- a/native/libs/binder/MemoryBase.cpp
+++ b/native/libs/binder/MemoryBase.cpp
@@ -14,7 +14,6 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "MemoryBase"
 
 #include <stdlib.h>
 #include <stdint.h>
@@ -45,11 +44,3 @@ MemoryBase::~MemoryBase()
 
 // ---------------------------------------------------------------------------
 }; // namespace android
-
-// Backwards compatibility for libdatabase_sqlcipher (http://b/8253769).
-extern "C" void _ZN7android10MemoryBaseC1ERKNS_2spINS_11IMemoryHeapEEEij(void*, void*, ssize_t, size_t);
-extern "C" void _ZN7android10MemoryBaseC1ERKNS_2spINS_11IMemoryHeapEEElj(void* obj, void* h, long o, unsigned int size) {
-    _ZN7android10MemoryBaseC1ERKNS_2spINS_11IMemoryHeapEEEij(obj, h, o, size);
-    ALOGW("Using temporary compatibility workaround for usage of MemoryBase "
-          "private API. Please fix your application!");
-}
diff --git a/native/libs/binder/MemoryHeapIon.cpp b/native/libs/binder/MemoryHeapIon.cpp
index 374b72e..460ba81 100644
--- a/native/libs/binder/MemoryHeapIon.cpp
+++ b/native/libs/binder/MemoryHeapIon.cpp
@@ -1,12 +1,12 @@
 /*
- * Copyright Samsung Electronics Co.,LTD.
- * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- * http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -14,176 +14,486 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/*!
- * \file MemoryHeapIon.cpp
- * \brief source file for MemoryHeapIon
- * \author MinGu, Jeon(mingu85.jeon)
- * \date 2011/11/20
- *
- * <b>Revision History: </b>
- * - 2011/11/20 : MinGu, Jeon(mingu85.jeon)) \n
- * Initial version
- * - 2012/11/29 : MinGu, Jeon(mingu85.jeon)) \n
- * Change name
- */
+
+#define LOG_TAG "MemoryHeapIon"
 
 #include <stdlib.h>
 #include <stdint.h>
 #include <unistd.h>
 #include <fcntl.h>
+#include <errno.h>
 #include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+
 #include <cutils/log.h>
-#include <binder/MemoryHeapBase.h>
-#include <binder/IMemory.h>
+
 #include <binder/MemoryHeapIon.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/mman.h>
-#include "ion.h"
+#include <binder/MemoryHeapBase.h>
 
-#define HEAP_MASK_FILTER    ((1 << 16) - (2))
-#define FLAG_MASK_FILTER    (~(HEAP_MASK_FILTER) - (1))
+#ifdef USE_TARGET_SIMULATOR_MODE
+#include <linux/ion.h>
+//modify for make sdk
+struct ion_phys_data {
+    int fd_buffer;
+    unsigned long phys;
+    size_t size;
+};
+
+struct ion_msync_data {
+    int fd_buffer;
+    void *vaddr;
+    void *paddr;
+    size_t size;
+};
+
+enum ION_SPRD_CUSTOM_CMD {
+    ION_SPRD_CUSTOM_PHYS,
+    ION_SPRD_CUSTOM_MSYNC
+};
+#else
+#include "ion.h"
+#include "ion_sprd.h"
+#endif
 
 namespace android {
 
-uint32_t ion_HeapMask_valid_check(uint32_t flags)
-{
-    uint32_t heap_mask, result;
-    result = 0;
-
-    heap_mask = flags & HEAP_MASK_FILTER;
-
-    switch(heap_mask) {
-        case MHB_ION_HEAP_SYSTEM_MASK:
-            return ION_HEAP_SYSTEM_MASK;
-        case MHB_ION_HEAP_SYSTEM_CONTIG_MASK:
-            return ION_HEAP_SYSTEM_CONTIG_MASK;
-        case MHB_ION_HEAP_EXYNOS_CONTIG_MASK:
-            return ION_HEAP_EXYNOS_CONTIG_MASK;
-        case MHB_ION_HEAP_EXYNOS_MASK:
-            return ION_HEAP_EXYNOS_MASK;
-        default:
-            ALOGE("MemoryHeapIon : Heap Mask flag is default (flags:%x)", flags);
-            return 0;
-            break;
+int  MemoryHeapIon::Get_phy_addr_from_ion(int buffer_fd, int *phy_addr, int *size){
+    int fd = open("/dev/ion", O_SYNC);
+    if(fd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_phys_data phys_data;
+        struct ion_custom_data  custom_data;
+        phys_data.fd_buffer = buffer_fd;
+        custom_data.cmd = ION_SPRD_CUSTOM_PHYS;
+        custom_data.arg = (unsigned long)&phys_data;
+        ret = ioctl(fd,ION_IOC_CUSTOM,&custom_data);
+        *phy_addr = phys_data.phys;
+        *size = phys_data.size;
+        close(fd);
+        if(ret)
+        {
+            ALOGE("%s: Getphyaddr error!",__func__);
+            return -2;
+        }
+    }
+    return 0;
+}
+
+int MemoryHeapIon::get_phy_addr_from_ion(int *phy_addr, int *size){
+    if(mIonDeviceFd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_phys_data phys_data;
+        struct ion_custom_data  custom_data;
+        phys_data.fd_buffer = MemoryHeapBase::getHeapID();
+        custom_data.cmd = ION_SPRD_CUSTOM_PHYS;
+        custom_data.arg = (unsigned long)&phys_data;
+        ret = ioctl(mIonDeviceFd,ION_IOC_CUSTOM,&custom_data);
+        *phy_addr = phys_data.phys;
+        *size = phys_data.size;
+        if(ret)
+        {
+            ALOGE("%s: getphyaddr error!",__func__);
+            return -2;
+        }
+     }
+    return 0;
+}
+
+int MemoryHeapIon::get_gsp_iova(int *mmu_addr, int *size){
+    if(mIonDeviceFd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+        mmu_data.fd_buffer = MemoryHeapBase::getHeapID();
+        custom_data.cmd = ION_SPRD_CUSTOM_GSP_MAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(mIonDeviceFd,ION_IOC_CUSTOM,&custom_data);
+        *mmu_addr = mmu_data.iova_addr;
+        *size = mmu_data.iova_size;
+        if(ret)
+        {
+            ALOGE("%s: get gsp iova error!",__func__);
+            return -2;
+        }
+     }
+    return 0;
+}
+
+int MemoryHeapIon::free_gsp_iova(int mmu_addr, int size){
+    if(mIonDeviceFd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+        mmu_data.fd_buffer = MemoryHeapBase::getHeapID();
+        mmu_data.iova_addr = mmu_addr;
+        mmu_data.iova_size = size;
+        custom_data.cmd = ION_SPRD_CUSTOM_GSP_UNMAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(mIonDeviceFd,ION_IOC_CUSTOM,&custom_data);
+        if(ret)
+        {
+            ALOGE("%s: free gsp iova error!",__func__);
+            return -2;
+        }
+     }
+    return 0;
+}
+
+int MemoryHeapIon::get_mm_iova(int *mmu_addr, int *size){
+    if(mIonDeviceFd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+        mmu_data.fd_buffer = MemoryHeapBase::getHeapID();
+        custom_data.cmd = ION_SPRD_CUSTOM_MM_MAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(mIonDeviceFd,ION_IOC_CUSTOM,&custom_data);
+        *mmu_addr = mmu_data.iova_addr;
+        *size = mmu_data.iova_size;
+        if(ret)
+        {
+            ALOGE("%s: get mm iova error!",__func__);
+            return -2;
+        }
+     }
+    return 0;
+}
+
+int MemoryHeapIon::free_mm_iova(int mmu_addr, int size){
+    if(mIonDeviceFd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+        mmu_data.fd_buffer = MemoryHeapBase::getHeapID();
+        mmu_data.iova_addr = mmu_addr;
+        mmu_data.iova_size = size;
+        custom_data.cmd = ION_SPRD_CUSTOM_MM_UNMAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(mIonDeviceFd,ION_IOC_CUSTOM,&custom_data);
+        if(ret)
+        {
+            ALOGE("%s: free mm iova error!",__func__);
+            return -2;
+        }
+     }
+    return 0;
+}
+int MemoryHeapIon::Get_gsp_iova(int buffer_fd,int *mmu_addr, int *size){
+    int fd = open("/dev/ion", O_SYNC);
+    if(fd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+
+        mmu_data.fd_buffer = buffer_fd;
+        custom_data.cmd = ION_SPRD_CUSTOM_GSP_MAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(fd,ION_IOC_CUSTOM,&custom_data);
+        *mmu_addr = mmu_data.iova_addr;
+        *size = mmu_data.iova_size;
+        close(fd);
+        if(ret)
+        {
+            ALOGE("%s: Get gsp iova error!",__func__);
+            return -2;
+        }
+    }
+    return 0;
+}
+int MemoryHeapIon::Get_mm_iova(int buffer_fd,int *mmu_addr, int *size){
+    int fd = open("/dev/ion", O_SYNC);
+    if(fd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+
+        mmu_data.fd_buffer =  buffer_fd;
+        custom_data.cmd = ION_SPRD_CUSTOM_MM_MAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(fd,ION_IOC_CUSTOM,&custom_data);
+        *mmu_addr = mmu_data.iova_addr;
+        *size = mmu_data.iova_size;
+        close(fd);
+        if(ret)
+        {
+            ALOGE("%s: Get mm iova error!",__func__);
+            return -2;
+        }
+    }
+    return 0;
+}
+
+int MemoryHeapIon::Free_gsp_iova(int buffer_fd,int mmu_addr, int size){
+    int fd = open("/dev/ion", O_SYNC);
+    if(fd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
+
+        mmu_data.fd_buffer = buffer_fd;
+        mmu_data.iova_addr = mmu_addr;
+        mmu_data.iova_size = size;
+        custom_data.cmd = ION_SPRD_CUSTOM_GSP_UNMAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(fd,ION_IOC_CUSTOM,&custom_data);
+        close(fd);
+        if(ret)
+        {
+            ALOGE("%s: Free gsp iova error!",__func__);
+            return -2;
+        }
     }
-    ALOGE("MemoryHeapIon : Heap Mask flag is wrong (flags:%x)", flags);
     return 0;
 }
+int MemoryHeapIon::Free_mm_iova(int buffer_fd,int mmu_addr, int size){
+    int fd = open("/dev/ion", O_SYNC);
+    if(fd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_mmu_data mmu_data;
+        struct ion_custom_data  custom_data;
 
-uint32_t ion_FlagMask_valid_check(uint32_t flags)
+        mmu_data.fd_buffer = buffer_fd;
+        mmu_data.iova_addr = mmu_addr;
+        mmu_data.iova_size = size;
+        custom_data.cmd = ION_SPRD_CUSTOM_MM_UNMAP;
+        custom_data.arg = (unsigned long)&mmu_data;
+        ret = ioctl(fd,ION_IOC_CUSTOM,&custom_data);
+        close(fd);
+        if(ret)
+        {
+            ALOGE("%s: Free mm iova error!",__func__);
+            return -2;
+        }
+    }
+    return 0;
+}
+
+bool MemoryHeapIon::Gsp_iommu_is_enabled(void)
 {
-    uint32_t flag_mask, result;
-    result = 0;
-
-    flag_mask = flags & FLAG_MASK_FILTER;
-
-    if (flag_mask & MHB_ION_FLAG_CACHED)
-        result |= ION_FLAG_CACHED;
-    if (flag_mask & MHB_ION_FLAG_CACHED_NEEDS_SYNC)
-        result |= ION_FLAG_CACHED_NEEDS_SYNC;
-    if (flag_mask & MHB_ION_FLAG_PRESERVE_KMAP)
-        result |= ION_FLAG_PRESERVE_KMAP;
-    if (flag_mask & MHB_ION_EXYNOS_VIDEO_MASK)
-        result |= ION_EXYNOS_VIDEO_MASK;
-    if (flag_mask & MHB_ION_EXYNOS_MFC_INPUT_MASK)
-        result |= ION_EXYNOS_MFC_INPUT_MASK;
-    if (flag_mask & MHB_ION_EXYNOS_MFC_OUTPUT_MASK)
-        result |= ION_EXYNOS_MFC_OUTPUT_MASK;
-    if (flag_mask & MHB_ION_EXYNOS_GSC_MASK)
-        result |= ION_EXYNOS_GSC_MASK;
-    if (flag_mask & MHB_ION_EXYNOS_FIMD_VIDEO_MASK)
-        result |= ION_EXYNOS_FIMD_VIDEO_MASK;
-
-    return result;
-}
-
-MemoryHeapIon::MemoryHeapIon(size_t size, uint32_t flags, char const *name):MemoryHeapBase()
+	if(access("/dev/sprd_iommu_gsp",F_OK)<0)
+	{
+		return false;
+	}
+	return true;
+}
+
+bool MemoryHeapIon::Mm_iommu_is_enabled(void)
 {
-    void* base = NULL;
-    int fd = -1;
-    uint32_t isReadOnly, heapMask, flagMask;
-
-    mIonClient = ion_client_create();
-
-    if (mIonClient < 0) {
-        ALOGE("MemoryHeapIon : ION client creation failed : %s", strerror(errno));
-        mIonClient = -1;
-    } else {
-        isReadOnly = flags & (IMemoryHeap::READ_ONLY);
-        heapMask = ion_HeapMask_valid_check(flags);
-        flagMask = ion_FlagMask_valid_check(flags);
-
-        if (heapMask) {
-            ALOGD("MemoryHeapIon : Allocated with size:%d, heap:0x%X , flag:0x%X", size, heapMask, flagMask);
-            fd = ion_alloc(mIonClient, size, 0, heapMask, flagMask);
-            if (fd < 0) {
-                ALOGE("MemoryHeapIon : ION Reserve memory allocation failed(size[%u]) : %s", size, strerror(errno));
-                if (errno == ENOMEM) { // Out of reserve memory. So re-try allocating in system heap
-                    ALOGD("MemoryHeapIon : Re-try Allocating in default heap - SYSTEM heap");
-                    fd = ion_alloc(mIonClient, size, 0, ION_HEAP_SYSTEM_MASK, ION_FLAG_CACHED | ION_FLAG_CACHED_NEEDS_SYNC | ION_FLAG_PRESERVE_KMAP);
-                }
-            }
-        } else {
-            fd = ion_alloc(mIonClient, size, 0, ION_HEAP_SYSTEM_MASK, ION_FLAG_CACHED | ION_FLAG_CACHED_NEEDS_SYNC | ION_FLAG_PRESERVE_KMAP);
-            ALOGD("MemoryHeapIon : Allocated with default heap - SYSTEM heap");
-        }
+	if(access("/dev/sprd_iommu_mm",F_OK)<0)
+	{
+		return false;
+	}
+	return true;
+}
 
-        flags = isReadOnly | heapMask | flagMask;
-
-        if (fd < 0) {
-            ALOGE("MemoryHeapIon : ION memory allocation failed(size[%u]) : %s", size, strerror(errno));
-        } else {
-            flags |= USE_ION_FD;
-            base = ion_map(fd, size, 0);
-            if (base != MAP_FAILED) {
-                init(fd, base, size, flags, NULL);
-            } else {
-                ALOGE("MemoryHeapIon : ION mmap failed(size[%u], fd[%d]) : %s", size, fd, strerror(errno));
-                ion_free(fd);
-            }
+int  MemoryHeapIon::Flush_ion_buffer(int buffer_fd, void *v_addr,void *p_addr,int size){
+       int fd = open("/dev/ion", O_SYNC);
+    if(fd<0){
+        ALOGE("%s:open dev ion error!",__func__);
+        return -1;
+    }else{
+        int ret;
+        struct ion_msync_data msync_data;
+        struct ion_custom_data  custom_data;
+
+        msync_data.fd_buffer = buffer_fd;
+        msync_data.vaddr = v_addr;
+        msync_data.paddr = p_addr;
+        msync_data.size = size;
+        custom_data.cmd = ION_SPRD_CUSTOM_MSYNC;
+        custom_data.arg = (unsigned long)&msync_data;
+        ret = ioctl(fd,ION_IOC_CUSTOM,&custom_data);
+        close(fd);
+        if(ret)
+        {
+            ALOGE("%s: Flush ion buffer error!",__func__);
+            return -2;
         }
     }
+    return 0;
+}
+
+int MemoryHeapIon::flush_ion_buffer(void *v_addr, void *p_addr,int size){
+    if(mIonDeviceFd<0){
+        return -1;
+    }else{
+        int ret;
+        struct ion_msync_data msync_data;
+        struct ion_custom_data  custom_data;
+
+        if ((v_addr<MemoryHeapBase::getBase())  ||  (v_addr+size>MemoryHeapBase::getBase()+MemoryHeapBase::getSize())){
+             ALOGE("flush_ion_buffer error  mBase=0x%x,mSize=0x%x",MemoryHeapBase::getBase(), MemoryHeapBase::getSize());
+             ALOGE("flush_ion_buffer error  v_addr=0x%x,p_addr=0x%x,size=0x%x",v_addr,p_addr,size);
+             return -3;
+        }
+        msync_data.fd_buffer = MemoryHeapBase::getHeapID();
+        msync_data.vaddr = v_addr;
+        msync_data.paddr = p_addr;
+        msync_data.size = size;
+        custom_data.cmd = ION_SPRD_CUSTOM_MSYNC;
+        custom_data.arg = (unsigned long)&msync_data;
+        ret = ioctl(mIonDeviceFd,ION_IOC_CUSTOM,&custom_data);
+        if(ret)
+        {
+            ALOGE("%s:flush ion buffer error!",__func__);
+            return -2;
+        }
+     }
+    return 0;
+}
+
+MemoryHeapIon::MemoryHeapIon() : mIonDeviceFd(-1), mIonHandle(NULL)
+{
 }
 
-MemoryHeapIon::MemoryHeapIon(int fd, size_t size, uint32_t flags, uint32_t offset):MemoryHeapBase()
+MemoryHeapIon::MemoryHeapIon(const char* device, size_t size,
+    uint32_t flags, unsigned long memory_types)
+    : MemoryHeapBase()
 {
-    void* base = NULL;
-    int dup_fd = -1;
-
-    mIonClient = ion_client_create();
-
-    if (mIonClient < 0) {
-        ALOGE("MemoryHeapIon : ION client creation failed : %s", strerror(errno));
-        mIonClient = -1;
-    } else {
-        if (fd >= 0) {
-            dup_fd = dup(fd);
-            if (dup_fd == -1) {
-                ALOGE("MemoryHeapIon : cannot dup fd (size[%u], fd[%d]) : %s", size, fd, strerror(errno));
-            } else {
-                flags |= USE_ION_FD;
-                base = ion_map(dup_fd, size, 0);
-                if (base != MAP_FAILED) {
-                    init(dup_fd, base, size, flags, NULL);
-                } else {
-                    ALOGE("MemoryHeapIon : ION mmap failed(size[%u], fd[%d]): %s", size, fd, strerror(errno));
-                    ion_free(dup_fd);
-                }
+    int open_flags = O_RDONLY;
+    if (flags & NO_CACHING)
+         open_flags |= O_SYNC;
+
+    int fd = open(device, open_flags);
+    if (fd >= 0) {
+            const size_t pagesize = getpagesize();
+            size = ((size + pagesize-1) & ~(pagesize-1));
+            if (mapIonFd(fd, size, memory_types, flags) == NO_ERROR) {
+                MemoryHeapBase::setDevice(device);
             }
-        } else {
-            ALOGE("MemoryHeapIon : fd parameter error(fd : %d)", fd);
+    }else {
+        ALOGE("open ion fail");
+    }
+}
+
+status_t MemoryHeapIon::ionInit(int ionFd, void *base, int size, int flags,
+                const char* device, struct ion_handle *handle,
+                int ionMapFd) {
+    mIonDeviceFd = ionFd;
+    mIonHandle = handle;
+    MemoryHeapBase::init(ionMapFd, base, size, flags, device);
+    return NO_ERROR;
+}
+
+
+status_t MemoryHeapIon::mapIonFd(int fd, size_t size, unsigned long memory_type, int uflags)
+{
+    /* If size is 0, just fail the mmap. There is no way to get the size
+     * with ion
+     */
+    int map_fd;
+
+    struct ion_allocation_data data;
+    struct ion_fd_data fd_data;
+    struct ion_handle_data handle_data;
+    void *base = NULL;
+
+    data.len = size;
+    data.align = getpagesize();
+#if (ION_DRIVER_VERSION == 1)
+    data.heap_mask = memory_type;
+    //if cached buffer , force set the lowest two bits 11
+    if((memory_type&(1<<31)))
+    {
+        data.flags = ((memory_type&(1<<31)) | 3);
+    }
+    else
+    {
+        data.flags = 0;
+    }
+#else
+    data.flags = memory_type;
+#endif
+
+    if (ioctl(fd, ION_IOC_ALLOC, &data) < 0) {
+        ALOGE("%s: ION_IOC_ALLOC error!",__func__);
+        close(fd);
+        return -errno;
+    }
+
+    if ((uflags & DONT_MAP_LOCALLY) == 0) {
+        int flags = 0;
+
+        fd_data.handle = data.handle;
+
+        if (ioctl(fd, ION_IOC_SHARE, &fd_data) < 0) {
+            ALOGE("%s: ION_IOC_SHARE error!",__func__);
+            handle_data.handle = data.handle;
+            ioctl(fd, ION_IOC_FREE, &handle_data);
+            close(fd);
+            return -errno;
+        }
+
+        base = (uint8_t*)mmap(0, size,
+                PROT_READ|PROT_WRITE, MAP_SHARED|flags, fd_data.fd, 0);
+        if (base == MAP_FAILED) {
+            ALOGE("mmap(fd=%d, size=%u) failed (%s)",
+                    fd, uint32_t(size), strerror(errno));
+            handle_data.handle = data.handle;
+            ioctl(fd, ION_IOC_FREE, &handle_data);
+            close(fd);
+            return -errno;
         }
     }
+    mIonHandle = data.handle;
+    mIonDeviceFd = fd;
+
+    /*
+     * Call this with NULL now and set device with set_device
+     * above for consistency sake with how MemoryHeapPmem works.
+     */
+    MemoryHeapBase::init(fd_data.fd, base, size, uflags, NULL);
+
+    return NO_ERROR;
 }
 
 MemoryHeapIon::~MemoryHeapIon()
 {
-    if (mIonClient != -1) {
-        ion_unmap(getBase(), getSize());
-        ion_client_destroy(mIonClient);
-        mIonClient = -1;
+    struct ion_handle_data data;
+
+    data.handle = mIonHandle;
+
+    /*
+     * Due to the way MemoryHeapBase is set up, munmap will never
+     * be called so we need to call it ourselves here.
+     */
+    munmap(MemoryHeapBase::getBase(), MemoryHeapBase::getSize());
+    if (mIonDeviceFd > 0) {
+        ioctl(mIonDeviceFd, ION_IOC_FREE, &data);
+        close(mIonDeviceFd);
     }
 }
 
-};
+// ---------------------------------------------------------------------------
+}; // namespace android
diff --git a/native/libs/binder/MemoryHeapPmem.cpp b/native/libs/binder/MemoryHeapPmem.cpp
deleted file mode 100644
index 66bcf4d..0000000
--- a/native/libs/binder/MemoryHeapPmem.cpp
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "MemoryHeapPmem"
-
-#include <stdlib.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-
-#include <cutils/log.h>
-
-#include <binder/MemoryHeapPmem.h>
-#include <binder/MemoryHeapBase.h>
-
-#ifdef HAVE_ANDROID_OS
-#include <linux/android_pmem.h>
-#endif
-
-namespace android {
-
-// ---------------------------------------------------------------------------
-
-MemoryHeapPmem::MemoryPmem::MemoryPmem(const sp<MemoryHeapPmem>& heap)
-    : BnMemory(), mClientHeap(heap)
-{
-}
-
-MemoryHeapPmem::MemoryPmem::~MemoryPmem() {
-    if (mClientHeap != NULL) {
-        mClientHeap->remove(this);
-    }
-}
-
-// ---------------------------------------------------------------------------
-
-class SubRegionMemory : public MemoryHeapPmem::MemoryPmem {
-public:
-    SubRegionMemory(const sp<MemoryHeapPmem>& heap, ssize_t offset, size_t size);
-    virtual ~SubRegionMemory();
-    virtual sp<IMemoryHeap> getMemory(ssize_t* offset, size_t* size) const;
-private:
-    friend class MemoryHeapPmem;
-    void revoke();
-    size_t              mSize;
-    ssize_t             mOffset;
-};
-
-SubRegionMemory::SubRegionMemory(const sp<MemoryHeapPmem>& heap,
-        ssize_t offset, size_t size)
-    : MemoryHeapPmem::MemoryPmem(heap), mSize(size), mOffset(offset)
-{
-#ifndef NDEBUG
-    void* const start_ptr = (void*)(intptr_t(getHeap()->base()) + offset);
-    memset(start_ptr, 0xda, size);
-#endif
-
-#ifdef HAVE_ANDROID_OS
-    if (size > 0) {
-        const size_t pagesize = getpagesize();
-        size = (size + pagesize-1) & ~(pagesize-1);
-        int our_fd = heap->heapID();
-        struct pmem_region sub = { offset, size };
-        int err = ioctl(our_fd, PMEM_MAP, &sub);
-        ALOGE_IF(err<0, "PMEM_MAP failed (%s), "
-                "mFD=%d, sub.offset=%lu, sub.size=%lu",
-                strerror(errno), our_fd, sub.offset, sub.len);
-}
-#endif
-}
-
-sp<IMemoryHeap> SubRegionMemory::getMemory(ssize_t* offset, size_t* size) const
-{
-    if (offset) *offset = mOffset;
-    if (size)   *size = mSize;
-    return getHeap();
-}
-
-SubRegionMemory::~SubRegionMemory()
-{
-    revoke();
-}
-
-
-void SubRegionMemory::revoke()
-{
-    // NOTE: revoke() doesn't need to be protected by a lock because it
-    // can only be called from MemoryHeapPmem::revoke(), which means
-    // that we can't be in ~SubRegionMemory(), or in ~SubRegionMemory(),
-    // which means MemoryHeapPmem::revoke() wouldn't have been able to 
-    // promote() it.
-    
-#ifdef HAVE_ANDROID_OS
-    if (mSize != 0) {
-        const sp<MemoryHeapPmem>& heap(getHeap());
-        int our_fd = heap->heapID();
-        struct pmem_region sub;
-        sub.offset = mOffset;
-        sub.len = mSize;
-        int err = ioctl(our_fd, PMEM_UNMAP, &sub);
-        ALOGE_IF(err<0, "PMEM_UNMAP failed (%s), "
-                "mFD=%d, sub.offset=%lu, sub.size=%lu",
-                strerror(errno), our_fd, sub.offset, sub.len);
-        mSize = 0;
-    }
-#endif
-}
-
-// ---------------------------------------------------------------------------
-
-MemoryHeapPmem::MemoryHeapPmem(const sp<MemoryHeapBase>& pmemHeap,
-        uint32_t flags)
-    : MemoryHeapBase()
-{
-    char const * const device = pmemHeap->getDevice();
-#ifdef HAVE_ANDROID_OS
-    if (device) {
-        int fd = open(device, O_RDWR | (flags & NO_CACHING ? O_SYNC : 0));
-        ALOGE_IF(fd<0, "couldn't open %s (%s)", device, strerror(errno));
-        if (fd >= 0) {
-            int err = ioctl(fd, PMEM_CONNECT, pmemHeap->heapID());
-            if (err < 0) {
-                ALOGE("PMEM_CONNECT failed (%s), mFD=%d, sub-fd=%d",
-                        strerror(errno), fd, pmemHeap->heapID());
-                close(fd);
-            } else {
-                // everything went well...
-                mParentHeap = pmemHeap;
-                MemoryHeapBase::init(fd, 
-                        pmemHeap->getBase(),
-                        pmemHeap->getSize(),
-                        pmemHeap->getFlags() | flags,
-                        device);
-            }
-        }
-    }
-#else
-    mParentHeap = pmemHeap;
-    MemoryHeapBase::init( 
-            dup(pmemHeap->heapID()),
-            pmemHeap->getBase(),
-            pmemHeap->getSize(),
-            pmemHeap->getFlags() | flags,
-            device);
-#endif
-}
-
-MemoryHeapPmem::~MemoryHeapPmem()
-{
-}
-
-sp<IMemory> MemoryHeapPmem::mapMemory(size_t offset, size_t size)
-{
-    sp<MemoryPmem> memory = createMemory(offset, size);
-    if (memory != 0) {
-        Mutex::Autolock _l(mLock);
-        mAllocations.add(memory);
-    }
-    return memory;
-}
-
-sp<MemoryHeapPmem::MemoryPmem> MemoryHeapPmem::createMemory(
-        size_t offset, size_t size)
-{
-    sp<SubRegionMemory> memory;
-    if (heapID() > 0) 
-        memory = new SubRegionMemory(this, offset, size);
-    return memory;
-}
-
-status_t MemoryHeapPmem::slap()
-{
-#ifdef HAVE_ANDROID_OS
-    size_t size = getSize();
-    const size_t pagesize = getpagesize();
-    size = (size + pagesize-1) & ~(pagesize-1);
-    int our_fd = getHeapID();
-    struct pmem_region sub = { 0, size };
-    int err = ioctl(our_fd, PMEM_MAP, &sub);
-    ALOGE_IF(err<0, "PMEM_MAP failed (%s), "
-            "mFD=%d, sub.offset=%lu, sub.size=%lu",
-            strerror(errno), our_fd, sub.offset, sub.len);
-    return -errno;
-#else
-    return NO_ERROR;
-#endif
-}
-
-status_t MemoryHeapPmem::unslap()
-{
-#ifdef HAVE_ANDROID_OS
-    size_t size = getSize();
-    const size_t pagesize = getpagesize();
-    size = (size + pagesize-1) & ~(pagesize-1);
-    int our_fd = getHeapID();
-    struct pmem_region sub = { 0, size };
-    int err = ioctl(our_fd, PMEM_UNMAP, &sub);
-    ALOGE_IF(err<0, "PMEM_UNMAP failed (%s), "
-            "mFD=%d, sub.offset=%lu, sub.size=%lu",
-            strerror(errno), our_fd, sub.offset, sub.len);
-    return -errno;
-#else
-    return NO_ERROR;
-#endif
-}
-
-void MemoryHeapPmem::revoke()
-{
-    SortedVector< wp<MemoryPmem> > allocations;
-
-    { // scope for lock
-        Mutex::Autolock _l(mLock);
-        allocations = mAllocations;
-    }
-    
-    ssize_t count = allocations.size();
-    for (ssize_t i=0 ; i<count ; i++) {
-        sp<MemoryPmem> memory(allocations[i].promote());
-        if (memory != 0)
-            memory->revoke();
-    }
-}
-
-void MemoryHeapPmem::remove(const wp<MemoryPmem>& memory)
-{
-    Mutex::Autolock _l(mLock);
-    mAllocations.remove(memory);
-}
-
-// ---------------------------------------------------------------------------
-}; // namespace android
diff --git a/native/libs/binder/Parcel.cpp b/native/libs/binder/Parcel.cpp
old mode 100644
new mode 100755
index 0464e93..db9e0a1
--- a/native/libs/binder/Parcel.cpp
+++ b/native/libs/binder/Parcel.cpp
@@ -384,7 +384,7 @@ status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
     // Count objects in range
     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
-        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
+        if ((off >= offset) && (off < offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
@@ -1144,10 +1144,6 @@ native_handle* Parcel::readNativeHandle() const
     if (err != NO_ERROR) return 0;
 
     native_handle* h = native_handle_create(numFds, numInts);
-    if (!h) {
-        return 0;
-    }
-
     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {
         h->data[i] = dup(readFileDescriptor());
         if (h->data[i] < 0) err = BAD_VALUE;
diff --git a/native/libs/binder/ion.h b/native/libs/binder/ion.h
new file mode 100644
index 0000000..aed8349
--- /dev/null
+++ b/native/libs/binder/ion.h
@@ -0,0 +1,344 @@
+/*
+ * include/linux/ion.h
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_ION_H
+#define _LINUX_ION_H
+
+#include <linux/types.h>
+
+struct ion_handle;
+/**
+ * enum ion_heap_types - list of all possible types of heaps
+ * @ION_HEAP_TYPE_SYSTEM:	 memory allocated via vmalloc
+ * @ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kmalloc
+ * @ION_HEAP_TYPE_CARVEOUT:	 memory allocated from a prereserved
+ * 				 carveout heap, allocations are physically
+ * 				 contiguous
+ * @ION_HEAP_END:		 helper for iterating over heaps
+ */
+enum ion_heap_type {
+	ION_HEAP_TYPE_SYSTEM,
+	ION_HEAP_TYPE_SYSTEM_CONTIG,
+	ION_HEAP_TYPE_CARVEOUT,
+	ION_HEAP_TYPE_CUSTOM, /* must be last so device specific heaps always
+				 are at the end of this enum */
+	ION_NUM_HEAPS,
+};
+
+#define ION_HEAP_SYSTEM_MASK		(1 << ION_HEAP_TYPE_SYSTEM)
+#define ION_HEAP_SYSTEM_CONTIG_MASK	(1 << ION_HEAP_TYPE_SYSTEM_CONTIG)
+#define ION_HEAP_CARVEOUT_MASK		(1 << ION_HEAP_TYPE_CARVEOUT)
+
+#ifdef __KERNEL__
+struct ion_device;
+struct ion_heap;
+struct ion_mapper;
+struct ion_client;
+struct ion_buffer;
+
+/* This should be removed some day when phys_addr_t's are fully
+   plumbed in the kernel, and all instances of ion_phys_addr_t should
+   be converted to phys_addr_t.  For the time being many kernel interfaces
+   do not accept phys_addr_t's that would have to */
+#define ion_phys_addr_t unsigned long
+
+/**
+ * struct ion_platform_heap - defines a heap in the given platform
+ * @type:	type of the heap from ion_heap_type enum
+ * @id:		unique identifier for heap.  When allocating (lower numbers 
+ * 		will be allocated from first)
+ * @name:	used for debug purposes
+ * @base:	base address of heap in physical memory if applicable
+ * @size:	size of the heap in bytes if applicable
+ *
+ * Provided by the board file.
+ */
+struct ion_platform_heap {
+	enum ion_heap_type type;
+	unsigned int id;
+	const char *name;
+	ion_phys_addr_t base;
+	size_t size;
+};
+
+/**
+ * struct ion_platform_data - array of platform heaps passed from board file
+ * @nr:		number of structures in the array
+ * @heaps:	array of platform_heap structions
+ *
+ * Provided by the board file in the form of platform data to a platform device.
+ */
+struct ion_platform_data {
+	int nr;
+	struct ion_platform_heap heaps[];
+};
+
+/**
+ * ion_client_create() -  allocate a client and returns it
+ * @dev:	the global ion device
+ * @heap_mask:	mask of heaps this client can allocate from
+ * @name:	used for debugging
+ */
+struct ion_client *ion_client_create(struct ion_device *dev,
+				     unsigned int heap_mask, const char *name);
+
+/**
+ * ion_client_destroy() -  free's a client and all it's handles
+ * @client:	the client
+ *
+ * Free the provided client and all it's resources including
+ * any handles it is holding.
+ */
+void ion_client_destroy(struct ion_client *client);
+
+/**
+ * ion_alloc - allocate ion memory
+ * @client:	the client
+ * @len:	size of the allocation
+ * @align:	requested allocation alignment, lots of hardware blocks have
+ *		alignment requirements of some kind
+ * @flags:	mask of heaps to allocate from, if multiple bits are set
+ *		heaps will be tried in order from lowest to highest order bit
+ *
+ * Allocate memory in one of the heaps provided in heap mask and return
+ * an opaque handle to it.
+ */
+struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
+			     size_t align, unsigned int flags);
+
+/**
+ * ion_free - free a handle
+ * @client:	the client
+ * @handle:	the handle to free
+ *
+ * Free the provided handle.
+ */
+void ion_free(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_phys - returns the physical address and len of a handle
+ * @client:	the client
+ * @handle:	the handle
+ * @addr:	a pointer to put the address in
+ * @len:	a pointer to put the length in
+ *
+ * This function queries the heap for a particular handle to get the
+ * handle's physical address.  It't output is only correct if
+ * a heap returns physically contiguous memory -- in other cases
+ * this api should not be implemented -- ion_map_dma should be used
+ * instead.  Returns -EINVAL if the handle is invalid.  This has
+ * no implications on the reference counting of the handle --
+ * the returned value may not be valid if the caller is not
+ * holding a reference.
+ */
+int ion_phys(struct ion_client *client, struct ion_handle *handle,
+	     ion_phys_addr_t *addr, size_t *len);
+
+/**
+ * ion_map_kernel - create mapping for the given handle
+ * @client:	the client
+ * @handle:	handle to map
+ *
+ * Map the given handle into the kernel and return a kernel address that
+ * can be used to access this address.
+ */
+void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_unmap_kernel() - destroy a kernel mapping for a handle
+ * @client:	the client
+ * @handle:	handle to unmap
+ */
+void ion_unmap_kernel(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_map_dma - create a dma mapping for a given handle
+ * @client:	the client
+ * @handle:	handle to map
+ *
+ * Return an sglist describing the given handle
+ */
+struct scatterlist *ion_map_dma(struct ion_client *client,
+				struct ion_handle *handle);
+
+/**
+ * ion_unmap_dma() - destroy a dma mapping for a handle
+ * @client:	the client
+ * @handle:	handle to unmap
+ */
+void ion_unmap_dma(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_share() - given a handle, obtain a buffer to pass to other clients
+ * @client:	the client
+ * @handle:	the handle to share
+ *
+ * Given a handle, return a buffer, which exists in a global name
+ * space, and can be passed to other clients.  Should be passed into ion_import
+ * to obtain a new handle for this buffer.
+ *
+ * NOTE: This function does do not an extra reference.  The burden is on the
+ * caller to make sure the buffer doesn't go away while it's being passed to
+ * another client.  That is, ion_free should not be called on this handle until
+ * the buffer has been imported into the other client.
+ */
+struct ion_buffer *ion_share(struct ion_client *client,
+			     struct ion_handle *handle);
+
+/**
+ * ion_import() - given an buffer in another client, import it
+ * @client:	this blocks client
+ * @buffer:	the buffer to import (as obtained from ion_share)
+ *
+ * Given a buffer, add it to the client and return the handle to use to refer
+ * to it further.  This is called to share a handle from one kernel client to
+ * another.
+ */
+struct ion_handle *ion_import(struct ion_client *client,
+			      struct ion_buffer *buffer);
+
+/**
+ * ion_import_fd() - given an fd obtained via ION_IOC_SHARE ioctl, import it
+ * @client:	this blocks client
+ * @fd:		the fd
+ *
+ * A helper function for drivers that will be recieving ion buffers shared
+ * with them from userspace.  These buffers are represented by a file
+ * descriptor obtained as the return from the ION_IOC_SHARE ioctl.
+ * This function coverts that fd into the underlying buffer, and returns
+ * the handle to use to refer to it further.
+ */
+struct ion_handle *ion_import_fd(struct ion_client *client, int fd);
+#endif /* __KERNEL__ */
+
+/**
+ * DOC: Ion Userspace API
+ *
+ * create a client by opening /dev/ion
+ * most operations handled via following ioctls
+ *
+ */
+
+/**
+ * struct ion_allocation_data - metadata passed from userspace for allocations
+ * @len:	size of the allocation
+ * @align:	required alignment of the allocation
+ * @flags:	flags passed to heap
+ * @handle:	pointer that will be populated with a cookie to use to refer
+ *		to this allocation
+ *
+ * Provided by userspace as an argument to the ioctl
+ */
+struct ion_allocation_data {
+	size_t len;
+	size_t align;
+	unsigned int flags;
+	struct ion_handle *handle;
+};
+
+/**
+ * struct ion_fd_data - metadata passed to/from userspace for a handle/fd pair
+ * @handle:	a handle
+ * @fd:		a file descriptor representing that handle
+ *
+ * For ION_IOC_SHARE or ION_IOC_MAP userspace populates the handle field with
+ * the handle returned from ion alloc, and the kernel returns the file
+ * descriptor to share or map in the fd field.  For ION_IOC_IMPORT, userspace
+ * provides the file descriptor and the kernel returns the handle.
+ */
+struct ion_fd_data {
+	struct ion_handle *handle;
+	int fd;
+};
+
+/**
+ * struct ion_handle_data - a handle passed to/from the kernel
+ * @handle:	a handle
+ */
+struct ion_handle_data {
+	struct ion_handle *handle;
+};
+
+/**
+ * struct ion_custom_data - metadata passed to/from userspace for a custom ioctl
+ * @cmd:	the custom ioctl function to call
+ * @arg:	additional data to pass to the custom ioctl, typically a user
+ *		pointer to a predefined structure
+ *
+ * This works just like the regular cmd and arg fields of an ioctl.
+ */
+struct ion_custom_data {
+	unsigned int cmd;
+	unsigned long arg;
+};
+
+#define ION_IOC_MAGIC		'I'
+
+/**
+ * DOC: ION_IOC_ALLOC - allocate memory
+ *
+ * Takes an ion_allocation_data struct and returns it with the handle field
+ * populated with the opaque handle for the allocation.
+ */
+#define ION_IOC_ALLOC		_IOWR(ION_IOC_MAGIC, 0, \
+				      struct ion_allocation_data)
+
+/**
+ * DOC: ION_IOC_FREE - free memory
+ *
+ * Takes an ion_handle_data struct and frees the handle.
+ */
+#define ION_IOC_FREE		_IOWR(ION_IOC_MAGIC, 1, struct ion_handle_data)
+
+/**
+ * DOC: ION_IOC_MAP - get a file descriptor to mmap
+ *
+ * Takes an ion_fd_data struct with the handle field populated with a valid
+ * opaque handle.  Returns the struct with the fd field set to a file
+ * descriptor open in the current address space.  This file descriptor
+ * can then be used as an argument to mmap.
+ */
+#define ION_IOC_MAP		_IOWR(ION_IOC_MAGIC, 2, struct ion_fd_data)
+
+/**
+ * DOC: ION_IOC_SHARE - creates a file descriptor to use to share an allocation
+ *
+ * Takes an ion_fd_data struct with the handle field populated with a valid
+ * opaque handle.  Returns the struct with the fd field set to a file
+ * descriptor open in the current address space.  This file descriptor
+ * can then be passed to another process.  The corresponding opaque handle can
+ * be retrieved via ION_IOC_IMPORT.
+ */
+#define ION_IOC_SHARE		_IOWR(ION_IOC_MAGIC, 4, struct ion_fd_data)
+
+/**
+ * DOC: ION_IOC_IMPORT - imports a shared file descriptor
+ *
+ * Takes an ion_fd_data struct with the fd field populated with a valid file
+ * descriptor obtained from ION_IOC_SHARE and returns the struct with the handle
+ * filed set to the corresponding opaque handle.
+ */
+#define ION_IOC_IMPORT		_IOWR(ION_IOC_MAGIC, 5, int)
+
+/**
+ * DOC: ION_IOC_CUSTOM - call architecture specific ion ioctl
+ *
+ * Takes the argument of the architecture specific ioctl to call and
+ * passes appropriate userdata for that ioctl
+ */
+#define ION_IOC_CUSTOM		_IOWR(ION_IOC_MAGIC, 6, struct ion_custom_data)
+
+#endif /* _LINUX_ION_H */
diff --git a/native/libs/binder/ion_sprd.h b/native/libs/binder/ion_sprd.h
new file mode 100644
index 0000000..70f00b0
--- /dev/null
+++ b/native/libs/binder/ion_sprd.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2012 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef	_ION_SPRD_H
+#define _ION_SPRD_H
+
+
+struct ion_phys_data {
+	int fd_buffer;
+	unsigned long phys;
+	size_t size;
+};
+
+struct ion_mmu_data {
+	int fd_buffer;
+	unsigned long iova_addr;
+	size_t iova_size;
+};
+
+struct ion_msync_data {
+	int fd_buffer;
+	void *vaddr;
+	void *paddr;
+	size_t size;
+};
+
+struct ion_map_data {
+	int fd_buffer;
+	unsigned long dev_addr;
+};
+
+struct ion_unmap_data {
+	int fd_buffer;
+};
+
+struct ion_fence_data {
+    int fence_fd;
+    char name[32];
+    unsigned long value;
+};
+
+enum ION_SPRD_CUSTOM_CMD {
+	ION_SPRD_CUSTOM_PHYS,
+	ION_SPRD_CUSTOM_MSYNC,
+
+	/* to get/free mmu iova */ //added by yfs
+	ION_SPRD_CUSTOM_GSP_MAP,
+	ION_SPRD_CUSTOM_GSP_UNMAP,
+	ION_SPRD_CUSTOM_MM_MAP,
+	ION_SPRD_CUSTOM_MM_UNMAP,
+        ION_SPRD_CUSTOM_FENCE_CREATE,
+        ION_SPRD_CUSTOM_FENCE_SIGNAL,
+        ION_SPRD_CUSTOM_FENCE_DUP,
+};
+
+#endif /* _ION_SPRD_H */
diff --git a/native/services/surfaceflinger/Android.mk b/native/services/surfaceflinger/Android.mk
index 0166b89..796ceb0 100644
--- a/native/services/surfaceflinger/Android.mk
+++ b/native/services/surfaceflinger/Android.mk
@@ -52,6 +52,11 @@ ifeq ($(TARGET_FORCE_HWC_FOR_VIRTUAL_DISPLAYS),true)
     LOCAL_CFLAGS += -DFORCE_HWC_COPY_FOR_VIRTUAL_DISPLAYS
 endif
 
+ifeq ($(BOARD_EGL_NEEDS_FNW),true)
+    LOCAL_CFLAGS += -DEGL_NEEDS_FNW
+endif
+
+
 ifneq ($(NUM_FRAMEBUFFER_SURFACE_BUFFERS),)
   LOCAL_CFLAGS += -DNUM_FRAMEBUFFER_SURFACE_BUFFERS=$(NUM_FRAMEBUFFER_SURFACE_BUFFERS)
 endif
diff --git a/native/services/surfaceflinger/DisplayDevice.cpp b/native/services/surfaceflinger/DisplayDevice.cpp
old mode 100755
new mode 100644
index 5f765bd..95b0f18
--- a/native/services/surfaceflinger/DisplayDevice.cpp
+++ b/native/services/surfaceflinger/DisplayDevice.cpp
@@ -29,6 +29,11 @@
 
 #include <gui/Surface.h>
 
+#ifdef EGL_NEEDS_FNW
+#include <ui/FramebufferNativeWindow.h>
+#endif
+
+
 #include <hardware/gralloc.h>
 
 #include "DisplayHardware/DisplaySurface.h"
@@ -75,8 +80,11 @@ DisplayDevice::DisplayDevice(
       mOrientation()
 {
     mNativeWindow = new Surface(producer, false);
+#ifndef EGL_NEEDS_FNW
     ANativeWindow* const window = mNativeWindow.get();
-
+#else
+    ANativeWindow* const window = new FramebufferNativeWindow();
+#endif
     int format;
     window->query(window, NATIVE_WINDOW_FORMAT, &format);
 
-- 
1.9.1

